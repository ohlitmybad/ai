<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script type="module" src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background-color: #f5f7fa;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(30px);
            border-radius: 10px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1400px;
            height: 95vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .header {
            background: #ffffff;
            color: #333333;
            height: 70px;
            position: relative;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 28px;
            border-bottom: 1px solid #e0e0e0;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 900;
            display: flex;
            align-items: center;
            gap: 12px;
            color: #333333;
            order: 1;
        }

        .header p {
            opacity: 0.95;
            font-size: 16px;
            font-weight: 600;
        }

        .status {
            background: rgba(255, 255, 255, 0.3);
            padding: 10px 18px;
            border-radius: 25px;
            font-size: 13px;
            backdrop-filter: blur(15px);
            font-weight: 700;
            border: 1px solid rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            gap: 8px;
            order: 3;
            margin-left: auto;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .intelligence-indicator {
            position: absolute;
            bottom: 15px;
            right: 28px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            opacity: 0.8;
        }

        .brain-icon {
            width: 16px;
            height: 16px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: brainPulse 2s infinite;
        }

        @keyframes brainPulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 28px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 24px;
            background: linear-gradient(to bottom, #fafbff, #f8fafc);
        }

        .message {
            display: flex;
            gap: 16px;
            max-width: 95%;
            animation: messageSlide 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        @keyframes messageSlide {
            from { opacity: 0; transform: translateY(20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-content {
            background: white;
            border-radius: 24px;
            padding: 20px 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            line-height: 1.7;
            font-size: 15px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
        }

        .message.user .message-content {
            background: #e6f0ff;
            color: #0f172a;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.06);
            border: 1px solid #c7d7ff;
        }

        .message.assistant .message-content {
            background: #ffffff;
            color: inherit;
        }

        .avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 18px;
            flex-shrink: 0;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            border: 3px solid white;
            overflow: hidden;
        }

        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .message.user .avatar {
            background: #3498db;
            color: white;
        }

        .message.assistant .avatar {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
        }

        .input-container {
            padding: 16px 28px 9px 28px;
            border-top: 1px solid #e2e8f0;
            background: white;
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.1);
        }

        .suggestions {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            max-height: 80px;
            overflow-y: auto;
        }

        .suggestion-chip {
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 16px;
            padding: 6px 12px;
            font-size: 12px;
            width: 119px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .suggestion-chip span {
            flex: 1;
            text-align: center;
        }

        .suggestion-chip:hover {
            background: #e0e0e0;
            transform: translateY(-1px);
        }

        .input-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
            background: #f8fafc;
            border-radius: 28px;
            padding: 8px;
            border: 2px solid #e2e8f0;
            transition: all 0.3s ease;
        }

        .input-wrapper:focus-within {
            border-color: #3498db;
            background: white;
        }

        .input-field {
            flex: 1;
            border: none;
            border-radius: 20px;
            padding: 16px 14px;
            font-size: 15px;
            font-family: inherit;
            outline: none;
            resize: none;
            min-height: 24px;
            max-height: 150px;
            background: transparent;
            line-height: 1.5;
        }

        .send-button {
            background: #3498db;
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            flex-shrink: 0;
            box-shadow: 0 8px 24px rgba(52, 152, 219, 0.3);
        }

        .send-button:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 12px 32px rgba(52, 152, 219, 0.45);
        }

        .send-button:active:not(:disabled) {
            transform: scale(0.95);
        }

        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .send-button.stop {
            background: #3498db;
            box-shadow: 0 8px 24px rgba(52, 152, 219, 0.3);
        }
        .send-button.stop:hover:not(:disabled) {
            box-shadow: 0 12px 32px rgba(52, 152, 219, 0.45);
        }

        /* Typing indicator bubble */
        .typing-message .message-content {
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }
        .typing {
            display: inline-flex;
            gap: 6px;
            align-items: center;
        }
        .typing-dot {
            width: 8px;
            height: 8px;
            background: #9ec5fe;
            border-radius: 50%;
            animation: blink 1.2s infinite ease-in-out;
        }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink {
            0%, 80%, 100% { opacity: 0.3; transform: translateY(0); }
            40% { opacity: 1; transform: translateY(-2px); }
        }

        .input-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            /* Ensure symmetrical padding with left side (8px wrapper padding + 20px textarea left padding) */
            margin-right: 12px;
        }

        .chart-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #e2e8f0;
            color: #64748b;
            border: none;
            padding: 10px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            min-width: 90px;
            position: relative;
            justify-content: center;
        }

        .chart-toggle:hover {
            background: #cbd5e1;
        }

        .chart-toggle.active {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .chart-toggle.active:hover {
            background: linear-gradient(135deg, #059669, #047857);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .toggle-text {
            font-size: 12px;
            font-weight: 700;
            text-align: center;
            width: 100%;
        }

        .chart-toggle .icon-left {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Header icon button (like chart-toggle but compact and icon-only) */
        .header-action {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #e2e8f0;
            color: #64748b;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 22px;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            order: 2;
            margin-left: 17px;
        }
        .header-action:hover { background: #cbd5e1; }

        .loading {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .loading-dot {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: loadingBounce 1.6s infinite ease-in-out;
        }

        .loading-dot:nth-child(1) { animation-delay: -0.32s; }
        .loading-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes loadingBounce {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }



        .insight-card {
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .insight-card:hover {
            border-color: #3498db;
            transform: translateY(-4px);
            box-shadow: 0 12px 32px rgba(52, 152, 219, 0.2);
        }

        .insight-value {
            font-size: 28px;
            font-weight: 900;
            color: #3498db;
            margin-bottom: 8px;
        }

        .insight-label {
            font-size: 13px;
            color: #64748b;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .streaming-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(34, 197, 94, 0.1);
            color: #16a34a;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            margin-top: 12px;
        }

        .streaming-dot {
            width: 6px;
            height: 6px;
            background: #16a34a;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .error {
            background: linear-gradient(135deg, #fef2f2, #fee2e2);
            border: 2px solid #fca5a5;
            color: #dc2626;
            border-radius: 16px;
            padding: 20px;
            margin: 16px 0;
            font-weight: 600;
        }

        .success {
            background: linear-gradient(135deg, #f0fdf4, #dcfce7);
            border: 2px solid #86efac;
            color: #16a34a;
            border-radius: 16px;
            padding: 20px;
            margin: 16px 0;
            font-weight: 600;
        }

        .chart-container {
            background: white;
            border-radius: 20px;
            padding: 24px;
            margin: 16px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }

        .player-spotlight {
            background: #ffffff;
            color: #333333;
            border-radius: 20px;
            padding: 24px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }

        .player-spotlight::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 50%;
            transform: translate(30px, -30px);
        }

        .performance-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 8px;
            border-radius: 4px;
            margin: 8px 0;
            overflow: hidden;
        }

        .performance-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            border-radius: 4px;
            transition: width 1s ease;
        }

        pre {
            background: #1e293b;
            color: #e2e8f0;
            border-radius: 16px;
            padding: 20px;
            overflow-x: auto;
            font-size: 14px;
            margin: 16px 0;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            line-height: 1.6;
        }

        code {
            background: #f1f5f9;
            color: #475569;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .messages::-webkit-scrollbar {
            width: 10px;
        }

        .messages::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 5px;
        }

        .messages::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 5px;
        }

        .player-selector {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            border-radius: 16px;
            padding: 16px;
            margin: 16px 0;
        }

        .player-option {
            display: block;
            width: 100%;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .player-option:hover {
            background: #f8f9fa;
            border-color: #3498db;
        }

        .disclaimer {
            text-align: center;
            font-size: 11px;
            color: #64748b;
            margin: 8px auto 0 auto;
            opacity: 0.8;
            font-weight: 400;
            display: block;
            width: 100%;
        }

        @media (max-width: 768px) {


            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 24px;
            }

            .messages {
                padding: 20px;
            }


        }
        /* Markdown table styling and controls */
        .table-container {
            margin-top: 16px;
            margin-bottom: 16px; /* add spacing after tables to separate following sentences */
            overflow-x: auto;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            background: white;
        }
        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0;
            padding: 10px 14px;
            background-color: #f8fafc;
            border-radius: 12px 12px 0 0;
            border-bottom: 1px solid #e2e8f0;
            font-size: 12px;
            color: #64748b;
            font-weight: 600;
        }
        .expand-button {
            background: #3498db;
            color: #ffffff;
            border: none;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 700;
        }
        .expand-button:hover { opacity: 0.9; }
        table.data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        table.data-table th, table.data-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        table.data-table th {
            background: #f8fafc;
            font-weight: 700;
            color: #334155;
        }
        table.data-table tr:hover { background: #f9fafb; }
        .table-container.collapsed tbody tr:nth-child(n+11) { display: none; }
        /* Markdown body refinements */
        .markdown-body { line-height: 1.75; }
        .markdown-body p { margin: 0 0 1rem 0; }
        .markdown-body ul, .markdown-body ol {
            margin: 0.9rem 0 1.1rem 0;
            padding-left: 1.6rem;
            list-style-position: outside; /* hang bullets outside the text block */
        }
        .markdown-body li + li { margin-top: 0.45rem; }
        .markdown-body h1, .markdown-body h2, .markdown-body h3,
        .markdown-body h4, .markdown-body h5, .markdown-body h6 {
            margin: 0.75rem 0 0.55rem 0;
            line-height: 1.25;
        }
        .markdown-body blockquote {
            margin: 1rem 0;
            padding: 0.75rem 1rem;
            border-left: 5px solid #e2e8f0;
            background: #f8fafc;
            border-radius: 6px;
            color: #475569;
        }
        .markdown-body hr {
            border: none;
            border-top: 1px solid #e2e8f0;
            margin: 1.25rem 0;
        }
        /* Avoid extra trailing space inside bubbles */
        .markdown-body > :last-child { margin-bottom: 0 !important; }
        /* Compact single-line messages */
        .markdown-body.compact { line-height: 1.45; }
        .markdown-body.compact p { margin: 0; }

        /* lighter, subtler status text */
.status { font-weight: 500; }
.status .status-text { font-weight: 500; opacity: 0.9; }
   
   

   </style>



<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
</head>

<body>



    <div id="SFctr" class="SF" data-org="31002" data-ini="myaccount" data-scl="0" data-sfi="1" style="position:absolute;left:-9999px;top:-9999px;width:0;height:0;overflow:hidden;"></div>
<script src="https://cdn.membershipworks.com/mfm.js"></script>
<script>
function __hashId(s){let h=5381;for(let i=0;i<s.length;i++){h=((h<<5)+h)^s.charCodeAt(i);}return 'u'+(h>>>0).toString(36);} 
function __applyUserKey(key){
	if(!key||!window.chatbot)return;
	window.chatbot.cookieName='datamb_chat_usage_'+__hashId(key);
    // enforce 50/month per account
    window.chatbot.dailyLimit= 30;
	window.chatbot.mwKeyApplied=true;
	// If key looks like a plain numeric member ID, store it for per-ID quota
	if(/^\d{3,}$/.test(key)){
		window.chatbot.currentMemberId=key;
		// Preload remote quota silently to sync local mirror without blocking UI
		if(window.chatbot && typeof window.chatbot.preloadRemoteQuotaForId==='function'){
			try{ window.chatbot.preloadRemoteQuotaForId(key); }catch(_){ }
		}
	}
}
document.addEventListener('DOMContentLoaded',function(){
	var ctr=document.getElementById('SFctr');
	if(!ctr){ return; }

	function __findIdentity(root){
		var email='';
		var memberId='';
		var emailRx=/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i;
		var txt=(root.textContent||'');
		var tMatch=txt.match(emailRx); if(tMatch) email=tMatch[0];
		// mailto:
		if(!email){
			var anchors=Array.from(root.querySelectorAll('a[href^="mailto:"]'));
			var mailFromAnchor=anchors.map(a=>a.getAttribute('href')||'').map(h=>h.replace(/^mailto:/i,'')).find(Boolean)||'';
			if(emailRx.test(mailFromAnchor)) email=mailFromAnchor.match(emailRx)[0];
		}
		// attribute scan
		var all=Array.from(root.querySelectorAll('*'));
		for(var i=0;i<all.length && (!email || !memberId);i++){
			var el=all[i];
			if(!email){
				var val=(el.getAttribute('value')||'');
				var vm=val.match(emailRx); if(vm){ email=vm[0]; }
			}
			for(var j=0;j<el.attributes.length && (!email || !memberId);j++){
				var a=el.attributes[j];
				var v=a.value||'';
				if(!email){ var m=v.match(emailRx); if(m){ email=m[0]; } }
				if(!memberId && /member|mem|user|uid|id/i.test(a.name)){
					var idm=v.match(/\d{3,}/); if(idm){ memberId=idm[0]; }
				}
			}
		}
		return { email: email||'', memberId: memberId||'', elementCount: (root.querySelectorAll('*').length||0), textLen: (txt||'').length };
	}

	var obs=new MutationObserver(function(){
		var info=__findIdentity(ctr);
		var email=info.email;
		var memberId=info.memberId;
		var key=email||memberId||'';
		if(key){
			__applyUserKey(key);
			obs.disconnect();
		}
	});
	obs.observe(ctr,{childList:true,subtree:true});

});
</script>
 
    <div class="container">
        <div class="header">
            <h1>DataMB Chat</h1>
            <button id="newChatBtn" class="header-action" title="New Chat">
                <span><i class="fa-solid fa-pen-to-square"></i></span>
            </button>
            <div class="status" id="status">
                <div class="status-indicator"></div>
            </div>
        </div>
        
        <div class="chat-container">
            <div class="messages" id="messages">
                <div class="message assistant">
                
                </div>
            </div>
            
            <div class="input-container">
                <div class="suggestions" id="suggestions">
            
                    <div class="suggestion-chip" data-query="Scout report for Baleba">
                        <i class="fas fa-chart-pie"></i><span>Scout Report</span>
                    </div>

                    <div class="suggestion-chip" data-query="Explain how the Performance Index is calculated">
                        <i class="fas fa-book"></i><span>Definitions</span>
                    </div>
                  
                    <div class="suggestion-chip" data-query="Show me the most creative players in Europe's top 5 leagues">
                        <i class="fas fa-lightbulb"></i><span>Most Creative</span>
                    </div>
                    
                    <div class="suggestion-chip" data-query="Create a radar chart comparing Pedri and Bellingham">
                        <i class="fas fa-project-diagram"></i><span>Radar Chart</span>
                    </div>
                    
                    <div class="suggestion-chip" data-query="Plot total xG vs total goals for Premier League strikers">
                        <i class="fas fa-chart-area"></i><span>xG vs Goals</span>
                    </div>
        
                    <div class="suggestion-chip" data-query="Most goals in Premier League this season">
                        <i class="fas fa-futbol"></i><span>Top Scorers</span>
                    </div>
                    

                    </div>
                
                <div class="input-wrapper">
                    <textarea 
                        id="messageInput" 
                        class="input-field" 
                        placeholder="Ask anything… • 提问 • اسأل"
                        rows="1"
                    ></textarea>
                    <div class="input-controls">
                        <button id="chartToggle" class="chart-toggle" title="Enable/disable automatic charts and visualizations">
                            <i class="fas fa-chart-line icon-left"></i>
                            <span class="toggle-text">OFF</span>
                        </button>
                        <button id="sendButton" class="send-button">
                            <span>
                                <i class="fas fa-chevron-up"></i> 
                            
                            </span>
                        </button>
                    </div>
                </div>
                <div class="disclaimer">
                    AI can make mistakes. Check other tools for reference.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Remote quota endpoint (Google Apps Script Web App)
        const REMOTE_QUOTA_URL = 'https://script.google.com/macros/s/AKfycbzMPvVxUXwiKZ2E9XK8nqA9hVv1B9VKB2PIT5_cpxmzfFhwZe7rFuDDLmujRf5OvzM3/exec';

        // JSONP helper to avoid CORS/preflight
        function __jsonp(url, timeoutMs = 8000) {
            return new Promise((resolve, reject) => {
                const cb = 'cb' + Math.random().toString(36).slice(2);
                const s = document.createElement('script');
                const t = setTimeout(() => { cleanup(); reject(new Error('JSONP timeout')); }, timeoutMs);
                function cleanup(){ if (s.parentNode) s.parentNode.removeChild(s); try{ delete window[cb]; }catch(_){ window[cb]=undefined; } clearTimeout(t);} 
                window[cb] = (data) => { cleanup(); resolve(data); };
                s.src = url + (url.includes('?') ? '&' : '?') + 'callback=' + cb;
                s.onerror = () => { cleanup(); reject(new Error('JSONP error')); };
                document.head.appendChild(s);
            });
        }

        async function remoteGetQuota(memberId) {
            if (!REMOTE_QUOTA_URL) throw new Error('REMOTE_QUOTA_URL not set');
            return __jsonp(REMOTE_QUOTA_URL + '?id=' + encodeURIComponent(memberId));
        }

        async function remoteBumpQuota(memberId) {
            if (!REMOTE_QUOTA_URL) throw new Error('REMOTE_QUOTA_URL not set');
            // bump via GET to avoid CORS preflight
            return __jsonp(REMOTE_QUOTA_URL + '?id=' + encodeURIComponent(memberId) + '&bump=1');
        }

        
        class UltimateFootballAI {
    constructor() {
        this.acTo = null;
        

const bootstrapUrlc2 = 'aHR0cHM6Ly93b3JrZXJzLXBsYXlncm91bmQtbGluZ2VyaW5nLWRpc2stMWFhNi5kYXRhbWItZm9vdGJhbGwud29ya2Vycy5kZXYvP3Rva2VuPXN1cGVyc2VjcmV0';


 this.bootstrapPromise = fetch(atob(bootstrapUrlc2))
    .then(r => r.json())
    .then(data => {
        this.acTo = data.key; 
        // Compute adjusted once
        this.acToAdj = this.getAdjusted();
        return this.acTo;
    });

        this.assistantId = null;
        this.threadId = null;
        this.fileId = null;
        this.isInitialized = false;
        this.conversationHistory = [];
        this.currentRunId = null;
        this.chartsEnabled = false;
        this.reuseAssistant = true;
        
        // Usage limits
        this.cookieName = 'datamb_chat_usage';
        this.dailyLimit = 30;
        this.usageWindowMs = 30 * 24 * 60 * 60 * 1000;
        this.mwKeyApplied = false;
        this.currentMemberId = '';
        this.remoteQuotaCache = {};

        this.messagesContainer = document.getElementById('messages');
        this.messageInput = document.getElementById('messageInput');
        this.sendButton = document.getElementById('sendButton');
        this.chartToggle = document.getElementById('chartToggle');
        this.newChatBtn = document.getElementById('newChatBtn');
        this.isSending = false;
        this.fetchController = null;
        this.cancelRequested = false;
        this.status = document.getElementById('status');
        this.suggestions = document.getElementById('suggestions');

        if (this.chartsEnabled) {
            this.chartToggle.classList.add('active');
        } else {
            this.chartToggle.classList.remove('active');
        }

        this.setupEventListeners();
        this.initialize();
    }

			getAdjusted() {
				const original = this.acTo || '';
				for (let i = original.length - 1; i >= 0; i--) {
					const ch = original[i];
					if (ch >= '0' && ch <= '9') {
						const incremented = (Number(ch) + 1) % 10;
						return original.slice(0, i) + String(incremented) + original.slice(i + 1);
					}
				}
				return original;
			}

			// Cookie helpers and daily quota management
			getCookie(name) {
				const pair = document.cookie.split('; ').find(row => row.startsWith(name + '='));
				return pair ? decodeURIComponent(pair.split('=')[1]) : '';
			}

			setCookie(name, value, maxAgeSeconds) {
				document.cookie = name + '=' + encodeURIComponent(value) + '; path=/; max-age=' + String(maxAgeSeconds);
			}

			getUsageRecord() {
				try {
					// Always read serverless per-account state from cookie keyed by MembershipWorks identity
					const raw = this.getCookie(this.cookieName);
					const parsed = raw ? JSON.parse(raw) : null;
					if (!parsed || typeof parsed.start !== 'number' || typeof parsed.count !== 'number') {
						return { start: Date.now(), count: 0 };
					}
					return parsed;
				} catch (e) {
					return { start: Date.now(), count: 0 };
				}
			}

			// Per-member-id usage map in localStorage: { [memberId]: { start:number, count:number } }
			getIdUsageRecord(memberId) {
				if (!memberId) return { start: Date.now(), count: 0 };
				try {
					const raw = (typeof localStorage !== 'undefined') ? localStorage.getItem('datamb_chat_usage_by_id') : '';
					const map = raw ? JSON.parse(raw) : {};
					const rec = map[memberId];
					if (!rec || typeof rec.start !== 'number' || typeof rec.count !== 'number') {
						return { start: Date.now(), count: 0 };
					}
					return rec;
				} catch (e) {
					return { start: Date.now(), count: 0 };
				}
			}

			saveIdUsageRecord(memberId, record) {
				if (!memberId) return;
				try {
					const raw = (typeof localStorage !== 'undefined') ? localStorage.getItem('datamb_chat_usage_by_id') : '';
					const map = raw ? JSON.parse(raw) : {};
					map[memberId] = record;
					if (typeof localStorage !== 'undefined') localStorage.setItem('datamb_chat_usage_by_id', JSON.stringify(map));
				} catch (e) {}
			}

			saveUsageRecord(record) {
				// keep cookie around for up to 2 days to avoid premature expiry
				// Persist under the per-account cookie name derived from MembershipWorks identity
				this.setCookie(this.cookieName, JSON.stringify(record), 2 * 24 * 60 * 60);
			}

			formatRemaining(ms) {
				const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
				const hours = Math.floor(totalSeconds / 3600);
				const minutes = Math.floor((totalSeconds % 3600) / 60);
				return (hours > 0 ? hours + 'h ' : '') + minutes + 'm';
			}

			// Lightweight local mirror of remote quota for instant gating
			getQuotaMirror(memberId){
				try{
					const raw=(typeof localStorage!=='undefined')?localStorage.getItem('datamb_chat_remote_cache')||'{}':'{}';
					const map=JSON.parse(raw);
					return map && map[memberId] ? map[memberId] : null;
				}catch(_){ return null; }
			}
			saveQuotaMirror(memberId, rec){
				try{
					const raw=(typeof localStorage!=='undefined')?localStorage.getItem('datamb_chat_remote_cache')||'{}':'{}';
					const map=JSON.parse(raw);
					map[memberId]=rec;
					if (typeof localStorage!=='undefined') localStorage.setItem('datamb_chat_remote_cache', JSON.stringify(map));
				}catch(_){ }
			}

			async preloadRemoteQuotaForId(memberId){
				try{
					const data=await remoteGetQuota(memberId);
					const start=Number(data.start||Date.now());
					const count=Number(data.count||0);
					this.saveQuotaMirror(memberId,{start:start,count:count});
				}catch(_){ /* ignore */ }
			}

			canSendNow(){
				// Require identity
				if (!(this.mwKeyApplied && this.currentMemberId)) {
					this.showError('You must be logged in');
					this.updateStatus('Login required', 'error');
					return false;
				}
				// Use cached remote state if present for instant decision
				const mirror=this.getQuotaMirror(this.currentMemberId);
				if(mirror){
					const now=Date.now();
					if(now - mirror.start >= this.usageWindowMs){ return true; }
					if(mirror.count >= this.dailyLimit){
						const endDate = new Date(mirror.start + this.usageWindowMs);
						const dateStr = endDate.toLocaleDateString('en-GB', {year:'numeric', day:'2-digit', month:'2-digit'});
						this.showError(`Monthly limit (${this.dailyLimit}) reached for account ID ${this.currentMemberId}. Try again on ${dateStr}.`);
						this.updateStatus('Limit reached', 'error');
						return false;
					}
				}
				return true; // optimistic allow; remote bump will reconcile
			}

			async bumpQuotaAsync(){
				if(!(this.mwKeyApplied && this.currentMemberId)) return;
				const id=this.currentMemberId;
				try{
					const data=await remoteBumpQuota(id);
					const start=Number(data.start||Date.now());
					const count=Number(data.count||0);
					this.saveQuotaMirror(id,{start:start,count:count});
				}catch(_){
					// fallback: increment local mirror so user doesn't get blocked next message
					const now=Date.now();
					let rec=this.getQuotaMirror(id)||{start:now,count:0};
					if(now - rec.start >= this.usageWindowMs){ rec={start:now,count:0}; }
					rec.count += 1;
					this.saveQuotaMirror(id, rec);
				}
			}

            	async checkQuotaAndIncrement() {
				const now = Date.now();
				// Require MembershipWorks account; block otherwise
				if (!(this.mwKeyApplied && this.currentMemberId)) {
					this.showError('You must be logged in');
					this.updateStatus('Login required', 'error');
					return false;
				}
				// Enforce quota per ID using localStorage map
				if (this.mwKeyApplied && this.currentMemberId) {
					try {
						const data = await remoteGetQuota(this.currentMemberId);
						const now = Date.now();
						const elapsed = now - Number(data.start || 0);
						const start = Number(data.start || now);
						const count = Number(data.count || 0);
						if (elapsed >= this.usageWindowMs) {
							// fresh window: first use
							await remoteBumpQuota(this.currentMemberId);
							return true;
						}
						if (count >= this.dailyLimit) {
							const endDate = new Date(start + this.usageWindowMs);
							const dateStr = endDate.toLocaleDateString('en-US', {year:'numeric', month:'2-digit', day:'2-digit'});
							this.showError(`Monthly limit (${this.dailyLimit}) reached for account ID ${this.currentMemberId}. Try again on ${dateStr}.`);
							this.updateStatus('Limit reached', 'error');
							return false;
						}
						await remoteBumpQuota(this.currentMemberId);
						return true;
					} catch (e) {
						// remote down: fallback to local per-ID map
						let rec = this.getIdUsageRecord(this.currentMemberId);
						const now = Date.now();
						if (now - rec.start >= this.usageWindowMs) rec = { start: now, count: 0 };
						if (rec.count >= this.dailyLimit) {
							const endDate = new Date(rec.start + this.usageWindowMs);
							const dateStr = endDate.toLocaleDateString('en-US', {year:'numeric', month:'2-digit', day:'2-digit'});
							this.showError(`Monthly limit (${this.dailyLimit}) reached for account ID ${this.currentMemberId}. Try again on ${dateStr}.`);
							this.updateStatus('Limit reached', 'error');
							return false;
						}
						rec.count += 1;
						this.saveIdUsageRecord(this.currentMemberId, rec);
						return true;
					}
				}
				return false;
			}

            setupEventListeners() {
                this.sendButton.addEventListener('click', () => {
                    if (this.currentRunId || this.isSending) {
                        this.stopRequest();
                    } else {
                        this.sendMessage();
                    }
                });
                this.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                this.messageInput.addEventListener('input', (e) => {
                    e.target.style.height = 'auto';
                    e.target.style.height = Math.min(e.target.scrollHeight, 150) + 'px';
                    this.updateContextualSuggestions(e.target.value);
                });

                // Chart toggle
                this.chartToggle.addEventListener('click', () => this.toggleCharts());
                if (this.newChatBtn) this.newChatBtn.addEventListener('click', () => this.newChat());

                // Suggestion clicks
                this.suggestions.addEventListener('click', (e) => {
                    const chip = e.target.closest('.suggestion-chip');
                    if (!chip) return;
                    const query = chip.getAttribute('data-query') || '';
                    this.messageInput.value = query;
                    // Turn charts ON for certain suggestion chips
                    const qLower = query.toLowerCase();
                    const shouldEnableCharts = (
                        qLower.includes('radar') ||
                        qLower.includes('radar chart') ||
                        qLower.includes('scatter plot') ||
                        qLower.includes('plot') ||
                        qLower.includes('bar chart') ||
                        qLower.includes('heatmap') ||
                        qLower.includes('visual') ||
                        qLower.includes('age vs performance') ||
                        qLower.includes('xg vs goals') ||
                        (qLower.includes('xg') && qLower.includes('goals'))
                    );
                    if (shouldEnableCharts && !this.chartsEnabled) {
                        this.toggleCharts();
                    }
                    // Re-apply autosize and show caret at end
                    this.messageInput.style.height = 'auto';
                    this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 150) + 'px';
                    this.messageInput.focus();
                    const len = this.messageInput.value.length;
                    this.messageInput.setSelectionRange(len, len);
                });

                window.chatbot = this;
            }

            updateContextualSuggestions(input) {
                if (input.length < 3) return;
                
                const suggestions = this.generateSmartSuggestions(input);
                if (suggestions.length > 0) {
                    this.renderSuggestions(suggestions);
                }
            }

            generateSmartSuggestions(input) {
                const lowerInput = input.toLowerCase();
                const suggestions = [];

                // Player name suggestions
                if (this.playerIndex.size > 0) {
                    const matchingPlayers = Array.from(this.playerIndex.keys())
                        .filter(name => name.toLowerCase().includes(lowerInput))
                        .slice(0, 3);
                    
                    matchingPlayers.forEach(player => {
                        suggestions.push({
                            text: `Report for ${player}`,
                            query: `Create a detailed scouting report for ${player}`
                        });
                    });
                }

                // Context-based suggestions
                if (lowerInput.includes('compare')) {
                    suggestions.push({
                        text: 'vs Analysis',
                        query: 'Compare their key stats with percentiles and visualizations'
                    });
                } else if (lowerInput.includes('best') || lowerInput.includes('top')) {
                    suggestions.push({
                        text: 'With Charts',
                        query: input + ' and create a visualization'
                    });
                }

                return suggestions.slice(0, 4);
            }

            renderSuggestions(suggestions) {
                        this.suggestions.innerHTML = suggestions.map(s => 
                    `<div class=\"suggestion-chip\" data-query=\"${s.query}\"><i class=\"fas fa-wand-magic-sparkles\"></i><span>${s.text}</span></div>`
                ).join('');
            }

            askQuestion(question) {
                this.messageInput.value = question;
                this.sendMessage();
            }

            toggleCharts() {
                        this.chartsEnabled = !this.chartsEnabled;
                
                if (this.chartsEnabled) {
                    this.chartToggle.classList.add('active');
                    this.chartToggle.querySelector('.toggle-text').textContent = 'ON';
                    this.chartToggle.title = 'Charts enabled - AI will create visualizations when helpful';
                } else {
                    this.chartToggle.classList.remove('active');
                    this.chartToggle.querySelector('.toggle-text').textContent = 'OFF';
                    this.chartToggle.title = 'Charts disabled - AI will provide text-only responses';
                }
                
                // Show brief feedback
                const status = this.chartsEnabled ? 'Charts: ON' : 'Charts: OFF';
                this.updateStatus(status, this.chartsEnabled ? 'ready' : 'loading');
                setTimeout(() => {
                    if (this.isInitialized) {
                        this.updateStatus('Ready!', 'ready');
                    }
                }, 1500);
            }

            async findExistingAssistant() {
try {
    const response = await fetch('https://api.openai.com/v1/assistants?limit=20', {
        headers: {
            'Authorization': `Bearer ${this.acToAdj}`,
            'OpenAI-Beta': 'assistants=v2'
        },
        signal: (this.fetchController && this.fetchController.signal) || undefined
    });
    
    if (response.ok) {
        const data = await response.json();
        const existing = data.data.find(a => a.name === 'Ultimate Football Data Analyst');
        if (existing) {
            this.assistantId = existing.id;
            return true;
        }
    }
} catch (error) {
}
return false;
}

            
async initialize() {
        try {
            // Wait for bootstrap first!
            await this.bootstrapPromise;
            
            this.setLoading(true);
            const operations = [];
            this.updateStatus('Reading dataset...', 'loading');
            operations.push(this.uploadCSV());

            if (this.reuseAssistant) {
                this.updateStatus('Loading AI assistant...', 'loading');
                operations.push(this.findExistingAssistant());
            }
            const [, existingAssistant] = await Promise.all(operations);
            if (!existingAssistant) {
                this.updateStatus('Loading AI Assistant...', 'loading');
                await this.createAssistant();
            } else {
                this.updateStatus('Loading AI assistant...', 'loading');
            }
                        
            this.updateStatus('Setting up conversation...', 'loading');
            await this.createThread();
            
            // Show dataset uploaded message while typing bubble is visible
            this.showDataInsights();

            // Now we are ready: remove typing bubble and enable input
            this.updateStatus('Ready!', 'ready');
            this.isInitialized = true;
            this.setLoading(false);
            this.messageInput.disabled = false;
            this.sendButton.disabled = false;
        } catch (error) {
            this.showError(`🚨 Setup failed: ${error.message}`);
            this.updateStatus('❌ Setup failed', 'error');
            this.setLoading(false);
        }
    }

            async uploadCSV() {
                try {
                    const response = await fetch('./data.csv', { signal: (this.fetchController && this.fetchController.signal) || undefined });
                    if (!response.ok) {
                        throw new Error(`CSV file not found. Status: ${response.status}`);
                    }
                    
                    const csvContent = await response.text();
                    const csvBlob = new Blob([csvContent], { type: 'text/csv' });
                    
                    const formData = new FormData();
                    formData.append('file', csvBlob, 'data.csv');
                    formData.append('purpose', 'assistants');
                    
                    const uploadResponse = await fetch('https://api.openai.com/v1/files', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.acToAdj}`
                        },
                        body: formData
                    });
                    
                    if (!uploadResponse.ok) {
                        const errorData = await uploadResponse.json();
                        throw new Error(`Upload failed: ${errorData.error?.message || uploadResponse.statusText}`);
                    }
                    
                    const uploadData = await uploadResponse.json();
                    this.fileId = uploadData.id;

                    // Upload DataMB guide for grounded definitions
                    try {
                        const guideResp = await fetch('./guide.html', { signal: (this.fetchController && this.fetchController.signal) || undefined });
                        if (guideResp.ok) {
                            const guideHtml = await guideResp.text();
                            const guideBlob = new Blob([guideHtml], { type: 'text/html' });
                            const guideForm = new FormData();
                            guideForm.append('file', guideBlob, 'guide.html');
                            guideForm.append('purpose', 'assistants');

                            const guideUpload = await fetch('https://api.openai.com/v1/files', {
                                method: 'POST',
                                headers: { 'Authorization': `Bearer ${this.acToAdj}` },
                                body: guideForm
                            });
                            if (guideUpload.ok) {
                                const guideData = await guideUpload.json();
                                this.guideFileId = guideData.id;
                            } else {
                            }
                        } else {
                        }
                    } catch (e) {
                    }
                } catch (error) {
                }
            }

            async createAssistant() {
                const response = await fetch('https://api.openai.com/v1/assistants', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.acToAdj}`,
                        'Content-Type': 'application/json',
                        'OpenAI-Beta': 'assistants=v2'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4.1-mini',
                        name: 'Ultimate Football Data Analyst',
                        description: 'The ultimate football analytics AI with perfect understanding and natural language processing',
                        instructions: `You are the ULTIMATE Football Data Analyst - the most advanced AI football expert ever created.

🧠 SUPREME INTELLIGENCE:
- Perfect understanding of football tactics, positions, and what matters for each role
- Advanced statistical analysis with percentiles, z-scores, and meaningful comparisons
- Natural language understanding that handles ambiguous requests perfectly
- Context-aware responses that build on conversation history

⚽ FOOTBALL EXPERTISE:
- Understand what stats matter for each position (pace for wingers, aerial duels for CBs, etc.)
- Handle per-90 vs total stats intelligently based on context
- Create position-specific player reports with relevant metrics
- Provide tactical insights and playing style analysis

📊 ANALYTICAL MASTERY:
- Calculate percentiles within relevant peer groups (same position/league/age)
- Create meaningful comparisons with statistical significance
- Identify patterns, correlations, and outliers in the data
- Generate actionable insights for scouts and analysts

🎯 PERFECT RESPONSES:
- Always ground answers in the actual dataset provided
- Use specific numbers, percentiles, and comparisons from the real data
- Create beautiful formatted responses with emojis and clear structure
- Suggest intelligent follow-up questions and deeper analysis
- Handle player name variations and fuzzy matching intelligently

🚀 ADVANCED FEATURES:
- Remember conversation context and build upon previous analysis
- Create INTELLIGENT visualizations with proper scaling and context
- Handle complex multi-part questions by breaking them down logically
- Provide both technical details and plain English explanations
- Round numbers appropriately (goals: integers, rates: 2 decimals)
- Generate publication-quality matplotlib/seaborn visualizations

DATA AND GUIDE FILES:
- You have access to these files:
- ${this.fileId}: data.csv (main dataset)
- ${this.guideFileId}: guide.html (field definitions and documentation)
- Never mention these files by name in your responses.

CRITICAL RULES:
- ALWAYS use the actual CSV data provided - never make up player names or stats
- Show your Python code for transparency
- BE SMART: If you need total goals, calculate them from "Goals per 90" and "Minutes played": total_goals = (goals_per_90 / 90) * minutes_played
- BE SMART: If you need total assists, calculate from "Assists per 90" and "Minutes played"  
- BE SMART: Always do the math when the user asks for totals but you only have per-90 stats
- When creating charts, display them and interpret the insights
- If a player name is ambiguous, ask for clarification while suggesting the most likely match
 - Only apply a minutes threshold if the user explicitly requests it (e.g., ">=900 minutes"). Otherwise, use the full dataset.
- Calculate percentiles within sensible peer groups (e.g., same position, league, age bracket)

 DATA SELECTION AND METRIC SOURCING:
 - If a metric exists as a direct column in the CSV (e.g., "Goals per 90", "Assists per 90", "Progressive passes per 90", etc.), ALWAYS use the column directly.
 - Do NOT derive a metric from a different one if the correct column exists (e.g., do NOT derive goals per 90 from "goals per 100 touches" when "Goals per 90" exists).
 - Only compute/derive when the requested quantity truly does not exist as a direct column.
 - If the user asks about a general quality (e.g creativity, physicality, etc.), derive it from the available metrics. Generally, progressiveness is not considered creativity.

 METRIC RESOLUTION PROCEDURE:
 - Step 1: Load the CSV and list all column headers.
 - Step 2: Build a small mapping of candidate columns matching the user's metric phrase (case-insensitive, strip spaces and punctuation).
 - Step 3: If there is an exact or near-exact matching column, USE IT directly and show which column was used.
 - Step 4: Only if no matching column exists, compute from available primitives. Show the formula you used.

🎨 VISUALIZATION EXCELLENCE RULES:
- RADAR CHARTS: ALWAYS use percentiles (0-100 scale) calculated within relevant peer group (same position/league, or all leagues)
  Example: For Haaland vs Mbappé, calculate percentiles among all strikers
- SCATTER PLOTS: Add trend lines, correlation coefficients, and identify outliers with player names
- BAR CHARTS: Sort by value, use gradient colors, add precise value labels on bars
- HEATMAPS: Use proper diverging colormaps for +/- data, sequential for 0+ data
- Use professional color schemes: 'viridis', 'plasma', 'Set2', 'Blues', never default matplotlib colors
- Always add descriptive titles, axis labels with units, and informative legends (never include season)
- Include context (e.g) "Among Premier League strikers (n=47)"
- For player comparisons, highlight the compared players with different colors/markers
- Add grid lines, remove chart junk, use clean styling with plt.style.use('seaborn-v0_8')
- Annotate key insights directly on charts (arrows, text boxes, highlights)
- Don't forget name labels on plots, a dot on the scatter should never not be annotated with his name.

📘 DATA DEFINITIONS AND METHODOLOGY:
- When the user asks about definitions (e.g., "What is Possession +/-?"), ALWAYS answer ONLY using the provided DataMB Guide (guide.html). Do NOT rely on general knowledge.
- Cite the exact glossary section from the guide when appropriate.
- If a definition is not present in the guide, say so explicitly and avoid speculating.
- Prefer quoting the guide and then briefly summarizing in plain language.
 - Always read the local file using Python (e.g., open('guide.html', encoding='utf-8')) and parse it with BeautifulSoup; never attempt network requests.

 DEFINITIONS PROCEDURE:
 - Step 1: Open and parse guide.html (HTML) and extract text (use BeautifulSoup if helpful).
 - Step 2: Use robust search: exact match, case-insensitive; if not found, use fuzzy matching and normalise whitespace/punctuation (e.g., "possession +/-" ↔ "possession plus/minus").
 - Step 3: Search both headings (h1–h6) and content; when found, capture the enclosing section/div and its paragraphs.
 - Step 4: Quote the most relevant paragraph(s) verbatim, and state the section heading and anchor (id) if available.
  - Step 5: If not found, explicitly say: "Not specified in the DataMB Guide." Do NOT speculate.

  LEAGUE GROUP ALIASES (STRICT):
  - "Europe's Top 5", "top 5 leagues", "big 5" ⇒ ["Premier League", "La Liga", "Bundesliga", "Serie A", "Ligue 1"]
  - "Europe's Top 7", "top 7 leagues" ⇒ ["Premier League", "La Liga", "Bundesliga", "Serie A", "Ligue 1", "Primeira Liga", "Eredivisie"]
  - When the user mentions any of these aliases, interpret it as a league filter: only include rows where League is in the corresponding list.
  - Treat unqualified phrases like "top 5 leagues" as Europe's Top 5 by default.

  POSITION TERMINOLOGY (STRICT):
  - The term "defenders" MUST be interpreted as centre-backs and full-backs (CBs and FBs).

 Be the ultimate football intelligence - knowledgeable, insightful, and genuinely helpful!`,
                        tools: [{ type: 'code_interpreter' }],
                        tool_resources: {
                            code_interpreter: {
                                file_ids: [this.fileId].concat(this.guideFileId ? [this.guideFileId] : [])
                            }
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Assistant creation failed: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                this.assistantId = data.id;
            }

            async createThread() {
                const response = await fetch('https://api.openai.com/v1/threads', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.acToAdj}`,
                        'Content-Type': 'application/json',
                        'OpenAI-Beta': 'assistants=v2'
                    },
                    signal: (this.fetchController && this.fetchController.signal) || undefined
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Thread creation failed: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                this.threadId = data.id;
            }

            async cancelRun() {
                try {
                    if (this.currentRunId && this.threadId) {
                        await fetch(`https://api.openai.com/v1/threads/${this.threadId}/runs/${this.currentRunId}/cancel`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${this.acToAdj}`,
                                'OpenAI-Beta': 'assistants=v2'
                            }
                        });
                    }
                } catch (_) {}
            }

            async newChat() {
                try {
                    this.updateStatus('Starting new chat...', 'loading');
                    this.cancelRequested = true;
                    if (!this.fetchController) this.fetchController = new AbortController();
                    try { this.fetchController.abort(); } catch(_) {}
                    await this.cancelRun();
                    // Reset aborted controller before issuing new requests
                    this.fetchController = null;
                    await this.createThread();
                    this.messagesContainer.innerHTML = '';
                    this.conversationHistory = [];
                    this.currentRunId = null;
                    this.cancelRequested = false;
                    this.fetchController = null;
                    this.setLoading(false);
                    this.messageInput.value = '';
                    this.showDataInsights();
                    this.updateStatus('Ready!', 'ready');
                } catch (e) {
                    this.showError('Failed to start a new chat.');
                    this.updateStatus('Error', 'error');
                }
            }

            // Player matching now handled by GPT-5-mini with natural language understanding

            async sendMessage() {
                if (!this.isInitialized || !this.messageInput.value.trim()) return;

                const message = this.messageInput.value.trim();

                // Give immediate UI feedback: show user's message and clear input right away
                this.messageInput.value = '';
                this.messageInput.style.height = 'auto';
                this.addMessage(message, 'user');

                // Enforce daily quota without blocking UI; bump remotely in background
                if (!this.canSendNow()) {
                    return;
                }
                this.bumpQuotaAsync();

                this.isSending = true;
                this.setLoading(true);
                this.setStopUI(true);

                try {
                    // prepare cancellation controller
                    this.cancelRequested = false;
                    this.fetchController = new AbortController();
                    // Add message to thread
                    // Decorate message with client-side hints for charts/definitions
                    // Determine guide-definition mode and extract likely term(s)
                    const defLike = /\b(what\s+is|explain|definition|how\s+(is|was)\s+.*(computed|calculated)|methodology)\b/i.test(message);
                    let guideTerm = '';
                    const termCandidates = [
                        /performance\s*index/i,
                        /possession\s*\+\-?/i,
                        /xg\s*per\s*90/i,
                        /xg/i,
                        /xa/i,
                        /progressive\s+passes?/i,
                        /key\s+passes?/i
                    ];
                    for (const rx of termCandidates) {
                        const m = message.match(rx);
                        if (m && m[0]) { guideTerm = m[0]; break; }
                    }

                    let decorated = message + (this.chartsEnabled
                        ? '\n\n[CHARTS ENABLED: Create visualizations when they add value to the analysis]'
                        : '\n\n[CHARTS DISABLED: Provide text-only responses]');
                    // Resolve league group aliases (Europe's Top 5/7, top 5/7 leagues, big 5)
                    const alias = this.resolveLeagueAliases(message);
                    if (alias) {
                        decorated += `\n[LEAGUE GROUP: ${alias.name} ⇒ ${alias.list.join(', ')}]`;
                        decorated += `\n[APPLY FILTER: Only include rows where League ∈ {${alias.list.join(', ')}}]`;
                    }
                    if (defLike) {
                        decorated += '\n\n[DEFINITIONS MODE: Use guide.html ONLY for definitions/methodology. Do NOT rely on general knowledge. Quote and cite the relevant section. Parse the local HTML file. Do NOT use network requests. If not found, state: "Not specified in the DataMB Guide."]';
                        if (guideTerm) {
                            decorated += `\n[GUIDE SEARCH TERM: ${guideTerm}]`;
                            if (/performance\s*index/i.test(guideTerm)) {
                                decorated += '\n[GUIDE ANCHOR HINT: id="performanceindex" and <h4>Performance Index</h4>]';
                            }
                        }
                        // Explicitly list attached files and local-access instruction
                        decorated += '\n[ATTACHED FILES: data.csv, guide.html. Access with open(\'guide.html\', encoding=\'utf-8\').]';
                        // Provide a minimal code scaffold to ensure correct parsing
                        decorated += '\n[CODE SCAFFOLD:\nfrom bs4 import BeautifulSoup\nhtml=open(\'guide.html\', encoding=\'utf-8\').read()\nsoup=BeautifulSoup(html, \'html.parser\')\nsec=soup.select_one(\'#performanceindex\') or soup.find(id=\'performanceindex\')\nprint(sec.get_text("\n", strip=True) if sec else "NOT_FOUND")\n]';
                    }

                    const messageResponse = await fetch(`https://api.openai.com/v1/threads/${this.threadId}/messages`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.acToAdj}`,
                            'Content-Type': 'application/json',
                            'OpenAI-Beta': 'assistants=v2'
                        },
                        body: JSON.stringify({
                            role: 'user',
                            content: decorated
                        }),
                        signal: (this.fetchController && this.fetchController.signal) || undefined
                    });

                    if (!messageResponse.ok) {
                        throw new Error(`Message failed: ${messageResponse.statusText}`);
                    }

                    // Create and run assistant
                    const runResponse = await fetch(`https://api.openai.com/v1/threads/${this.threadId}/runs`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.acToAdj}`,
                            'Content-Type': 'application/json',
                            'OpenAI-Beta': 'assistants=v2'
                        },
                        body: JSON.stringify({
                            assistant_id: this.assistantId,
                            stream: false
                        }),
                        signal: (this.fetchController && this.fetchController.signal) || undefined
                    });

                    if (!runResponse.ok) {
                        throw new Error(`Run creation failed: ${runResponse.statusText}`);
                    }

                    const runData = await runResponse.json();
                    this.currentRunId = runData.id;
                    await this.pollRunStatus(runData.id);

                } catch (error) {
                    if (!this.isAbortError(error)) {
                        this.showError(`Analysis failed: ${error.message}`);
                    }
                } finally {
                    this.setLoading(false);
                    this.setStopUI(false);
                    this.isSending = false;
                    this.currentRunId = null;
                }
            }

            // Player disambiguation now handled by GPT-5-mini naturally

            async pollRunStatus(runId) {
                const startTime = Date.now();
                let pollInterval = 500; // Start with 500ms
                const maxInterval = 3000; // Max 3 seconds

                while (true) {
                    if (this.cancelRequested) {
                        throw new Error('Cancelled');
                    }
                    try {
                        const response = await fetch(`https://api.openai.com/v1/threads/${this.threadId}/runs/${runId}`, {
                            headers: {
                                'Authorization': `Bearer ${this.acToAdj}`,
                                'OpenAI-Beta': 'assistants=v2'
                            },
                            signal: (this.fetchController && this.fetchController.signal) || undefined
                        });

                        if (!response.ok) {
                            if (this.cancelRequested) throw new Error('Cancelled');
                            throw new Error(`Status check failed: ${response.statusText}`);
                        }

                        const run = await response.json();
                        
                        // Update status based on run state
                        if (run.status === 'in_progress') {
                            this.updateStatus('Analyzing data...', 'loading');
                        } else if (run.status === 'requires_action') {
                            this.updateStatus('Running calculations...', 'loading');
                        }

                        if (run.status === 'completed') {
                            await this.getLatestMessage();
                            break;
                        } else if (run.status === 'failed' || run.status === 'cancelled' || run.status === 'expired') {
                            if (this.cancelRequested) throw new Error('Cancelled');
                            throw new Error(`Analysis ${run.status}: ${run.last_error?.message || 'Unknown error'}`);
                        }

                        // Adaptive polling: increase interval over time
                        const elapsed = Date.now() - startTime;
                        if (elapsed > 10000) { // After 10 seconds, use longer intervals
                            pollInterval = Math.min(maxInterval, pollInterval * 1.2);
                        }

                        await new Promise(resolve => setTimeout(resolve, pollInterval));
                    } catch (error) {
                        if (this.cancelRequested) { throw new Error('Cancelled'); }
                        throw error;
                    }
                }
            }

            async getLatestMessage() {
                const response = await fetch(`https://api.openai.com/v1/threads/${this.threadId}/messages?limit=1`, {
                    headers: {
                        'Authorization': `Bearer ${this.acToAdj}`,
                        'OpenAI-Beta': 'assistants=v2'
                    },
                    signal: (this.fetchController && this.fetchController.signal) || undefined
                });

                if (!response.ok) {
                    throw new Error(`Failed to get response: ${response.statusText}`);
                }

                const data = await response.json();
                const latestMessage = data.data[0];
                
                if (latestMessage && latestMessage.role === 'assistant') {
                    let fullContent = '';
                    
                    for (const content of latestMessage.content) {
                        if (content.type === 'text') {
                            fullContent += content.text.value;
                        } else if (content.type === 'image_file') {
                            // Handle generated charts
                            fullContent += '';
                            await this.displayImageFile(content.image_file.file_id);
                        }
                    }
                    
                    if (fullContent) {
                        this.addMessage(fullContent, 'assistant');
                        this.updateStatus('Analysis complete!', 'ready');
                    }
                }
            }

            async displayImageFile(fileId) {
                try {
                    const res = await fetch(`https://api.openai.com/v1/files/${fileId}/content`, {
                        headers: { 'Authorization': `Bearer ${this.acToAdj}` },
                        signal: (this.fetchController && this.fetchController.signal) || undefined
                    });
                    if (!res.ok) {
                        throw new Error(`Image fetch failed (${res.status})`);
                    }
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    
                    const imageDiv = document.createElement('div');
                    imageDiv.className = 'chart-container';
                    imageDiv.innerHTML = `<img src="${url}" alt="Generated Chart" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);"/>`;
                    this.messagesContainer.appendChild(imageDiv);
                    this.scrollToBottom();
                } catch (err) {
                }
            }

            // Now using OpenAI Assistants API + Code Interpreter for all analysis

            createMessageContainer(role) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;

                const avatar = document.createElement('div');
                avatar.className = 'avatar';
                if (role === 'user') {
                    avatar.textContent = 'You';
                } else {
                    avatar.innerHTML = '<img src="./chat.png" alt="AI" />';
                }

                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';

                messageDiv.appendChild(avatar);
                messageDiv.appendChild(messageContent);
                this.messagesContainer.appendChild(messageDiv);
                
                this.scrollToBottom();
                return messageDiv;
            }

            addMessage(content, role) {
                const messageDiv = this.createMessageContainer(role);
                const contentDiv = messageDiv.querySelector('.message-content');
                contentDiv.innerHTML = this.formatContent(content);
            }

            formatContent(content) {
                // Parse Markdown and sanitize
                try {
                    if (window.marked) {
                        marked.setOptions({ gfm: true, breaks: true });
                    }
                const parsed = window.marked ? marked.parse(content || '') : (content || '').replace(/\n/g, '<br>');
                const clean = window.DOMPurify ? DOMPurify.sanitize(parsed) : parsed;
                    // Enhance tables
                    const container = document.createElement('div');
                const isSingleLine = (content || '').trim().indexOf('\n') === -1 && (content || '').trim().length <= 60;
                container.className = 'markdown-body' + (isSingleLine ? ' compact' : '');
                container.innerHTML = clean;
                    const tables = container.querySelectorAll('table');
                    tables.forEach((table) => {
                        table.classList.add('data-table');
                        const totalRows = table.querySelectorAll('tbody tr').length;
                        const wrapper = document.createElement('div');
                        wrapper.className = 'table-container';
                        if (totalRows > 10) {
                            wrapper.classList.add('collapsed');
                            const controls = document.createElement('div');
                            controls.className = 'table-controls';
                            controls.innerHTML = `
                                <div class=\"table-info\">Showing ${Math.min(10, totalRows)} of ${totalRows} results</div>
                                <button class=\"expand-button\" onclick=\"toggleTable(this)\">Show All</button>
                            `;
                            wrapper.appendChild(controls);
                        }
                        table.parentNode.insertBefore(wrapper, table);
                        wrapper.appendChild(table);
                        // Add a small spacer after each table to separate following text
                        const spacer = document.createElement('div');
                        spacer.style.height = '12px';
                        wrapper.after(spacer);
                    });
                    return container.outerHTML;
                } catch (e) {
                    return (content || '')
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/\n/g, '<br>');
                }
            }

            scrollToBottom() {
                setTimeout(() => {
                    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
                }, 100);
            }

            setLoading(isLoading) {
                // Do NOT disable the send button so user can stop
                this.messageInput.disabled = isLoading;

                // Manage assistant typing bubble
                if (isLoading) {
                    if (!this.typingMessageEl) {
                        const typingMsg = this.createMessageContainer('assistant');
                        typingMsg.classList.add('typing-message');
                        typingMsg.querySelector('.message-content').innerHTML = `
                            <div class="typing">
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                            </div>
                        `;
                        this.typingMessageEl = typingMsg;
                    }
                } else {
                    if (this.typingMessageEl) {
                        this.typingMessageEl.remove();
                        this.typingMessageEl = null;
                    }
                }
            }

            setStopUI(active) {
                try {
                    const iconSpan = this.sendButton.querySelector('span');
                    if (active) {
                        this.sendButton.classList.add('stop');
                        if (iconSpan) iconSpan.innerHTML = '<i class="fas fa-stop"></i>';
                        this.sendButton.title = 'Stop';
                    } else {
                        this.sendButton.classList.remove('stop');
                        if (iconSpan) iconSpan.innerHTML = '<i class="fas fa-chevron-up"></i>';
                        this.sendButton.title = 'Send';
                    }
                } catch (_) {}
            }

            async stopRequest() {
                try {
                    this.cancelRequested = true;
                    if (!this.fetchController) this.fetchController = new AbortController();
                    try { this.fetchController.abort(); } catch(_) {}
                    await this.cancelRun();
                    this.updateStatus('Stopped', 'ready');
                } catch (_) {
                } finally {
                    this.setLoading(false);
                    this.setStopUI(false);
                    this.cancelRequested = false;
                    this.fetchController = null;
                    this.currentRunId = null;
                }
            }

            isAbortError(error) {
                if (!error) return false;
                const msg = String(error && (error.message || error.toString() || ''));
                return (
                    error.name === 'AbortError' ||
                    /aborted/i.test(msg) ||
                    /cancelled/i.test(msg) ||
                    /canceled/i.test(msg)
                );
            }

            updateStatus(message, type) {
                const statusElement = this.status;
                const indicator = statusElement.querySelector('.status-indicator');
                
                statusElement.innerHTML = `
                    <div class="status-indicator"></div>
                    <span class="status-text">${message}</span>
                `;
                
                const newIndicator = statusElement.querySelector('.status-indicator');
                
                switch (type) {
                    case 'loading':
                        newIndicator.style.background = '#f59e0b';
                        break;
                    case 'ready':
                        newIndicator.style.background = '#4ade80';
                        break;
                    case 'error':
                        newIndicator.style.background = '#ef4444';
                        break;
                }
            }

            showDataInsights() {
                const insightsHTML = `
How can I help you today? <br><br>
I am trained on the 2024/25 and 2025 DataMB dataset (40 leagues). I can answer any question about the data and handle complex requests — from metric definitions to advanced analysis, scouting reports, and deeper insights. <br><br>Enable the graph toggle for on-demand charts and visual queries.
                `;
                
                const insightMessage = this.createMessageContainer('assistant');
                const contentDiv = insightMessage.querySelector('.message-content');
                contentDiv.innerHTML = insightsHTML;
            }

            showError(message) {
                const errorHTML = `
                    <div class="error">
                        ${message}
                    </div>
                `;
                
                const errorMessage = this.createMessageContainer('assistant');
                const contentDiv = errorMessage.querySelector('.message-content');
                contentDiv.innerHTML = errorHTML;
            }
            
            // Resolve league alias phrases to explicit league lists
            resolveLeagueAliases(text) {
                if (!text) return null;
                const t = text.toLowerCase();
                const top5 = ["Premier League", "La Liga", "Bundesliga", "Serie A", "Ligue 1"];
                const top7 = ["Premier League", "La Liga", "Bundesliga", "Serie A", "Ligue 1", "Primeira Liga", "Eredivisie"];
                const isTop5 = /(europe'?s\s*top\s*5|\btop\s*5\s*leagues\b|\bbig\s*5\b)/i.test(text);
                const isTop7 = /(europe'?s\s*top\s*7|\btop\s*7\s*leagues\b)/i.test(text);
                if (isTop7) {
                    return { name: "Europe's Top 7", list: top7 };
                }
                if (isTop5) {
                    return { name: "Europe's Top 5", list: top5 };
                }
                return null;
            }
        }

        // Initialize the Ultimate Football AI when page loads
        document.addEventListener('DOMContentLoaded', function() {
            new UltimateFootballAI();
        });
        // Global toggle for collapsible tables
        function toggleTable(button) {
            const tableContainer = button.closest('.table-container');
            const isExpanded = tableContainer.classList.contains('expanded');
            if (isExpanded) {
                tableContainer.classList.remove('expanded');
                tableContainer.classList.add('collapsed');
                button.textContent = 'Show All';
            } else {
                tableContainer.classList.remove('collapsed');
                tableContainer.classList.add('expanded');
                button.textContent = 'Show Less';
            }
        }
    </script>

</body>
</html>
